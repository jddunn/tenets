"""Report generation module.

This module orchestrates report generation by combining analysis data
with visualizations from the viz package. It creates structured reports
in various formats without duplicating visualization logic.
"""

import json
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from tenets.config import TenetsConfig
from tenets.utils.logger import get_logger

# Import visualizers from viz package
from tenets.viz import (
    ChartConfig,
    ComplexityVisualizer,
    ContributorVisualizer,
    CouplingVisualizer,
    DependencyVisualizer,
    HotspotVisualizer,
    MomentumVisualizer,
)


@dataclass
class ReportSection:
    """Represents a section in the report.

    A report section contains structured content including text,
    metrics, tables, and charts. Sections can be nested to create
    hierarchical report structures.

    Attributes:
        id: Unique section identifier
        title: Section title
        level: Heading level (1-6)
        order: Display order
        icon: Optional icon/emoji
        content: Section text content
        metrics: Key metrics dictionary
        tables: List of table data
        charts: List of chart configurations
        code_snippets: List of code examples
        subsections: Nested sections
        visible: Whether section is visible
        collapsed: Whether section starts collapsed
    """

    id: str
    title: str
    level: int = 1
    order: int = 0
    icon: Optional[str] = None
    content: Optional[Union[str, List[str], Dict[str, Any]]] = None
    metrics: Dict[str, Any] = field(default_factory=dict)
    tables: List[Dict[str, Any]] = field(default_factory=list)
    charts: List[Dict[str, Any]] = field(default_factory=list)
    code_snippets: List[Dict[str, Any]] = field(default_factory=list)
    subsections: List["ReportSection"] = field(default_factory=list)
    visible: bool = True
    collapsed: bool = False

    def add_metric(self, name: str, value: Any) -> None:
        """Add a metric to the section.

        Args:
            name: Metric name
            value: Metric value
        """
        self.metrics[name] = value

    def add_table(self, table_data: Dict[str, Any]) -> None:
        """Add a table to the section.

        Args:
            table_data: Table configuration with headers and rows
        """
        self.tables.append(table_data)

    def add_chart(self, chart_config: Dict[str, Any]) -> None:
        """Add a chart to the section.

        Args:
            chart_config: Chart configuration from viz modules
        """
        self.charts.append(chart_config)

    def add_subsection(self, subsection: "ReportSection") -> None:
        """Add a subsection.

        Args:
            subsection: Nested section
        """
        self.subsections.append(subsection)


@dataclass
class ReportConfig:
    """Configuration for report generation.

    Controls report generation options including format, content
    inclusion, and visualization settings.

    Attributes:
        title: Report title
        format: Output format (html, markdown, json)
        include_summary: Include executive summary
        include_toc: Include table of contents
        include_charts: Include visualizations
        include_code_snippets: Include code examples
        include_recommendations: Include recommendations
        max_items: Maximum items in lists
        theme: Visual theme (light, dark, auto)
        footer_text: Footer text
        custom_css: Custom CSS for HTML reports
        chart_config: Default chart configuration
    """

    title: str = "Code Analysis Report"
    format: str = "html"
    include_summary: bool = True
    include_toc: bool = True
    include_charts: bool = True
    include_code_snippets: bool = True
    include_recommendations: bool = True
    max_items: int = 20
    theme: str = "light"
    footer_text: str = "Generated by Tenets Code Analysis"
    custom_css: Optional[str] = None
    chart_config: Optional[ChartConfig] = None


class ReportGenerator:
    """Main report generator orchestrator.

    Coordinates report generation by combining analysis data with
    visualizations from the viz package. Creates structured reports
    without duplicating visualization logic.

    The generator follows a clear separation of concerns:
    - Core modules provide analysis data
    - Viz modules create visualizations
    - Generator orchestrates and structures the report

    Attributes:
        config: Configuration object
        logger: Logger instance
        sections: List of report sections
        metadata: Report metadata
    """

    def __init__(self, config: TenetsConfig):
        """Initialize report generator.

        Args:
            config: Configuration object
        """
        self.config = config
        self.logger = get_logger(__name__)
        self.sections: List[ReportSection] = []
        self.metadata: Dict[str, Any] = {}

    def generate(
        self, data: Dict[str, Any], output_path: Path, config: Optional[ReportConfig] = None
    ) -> Path:
        """Generate a report from analysis data.

        This is the main entry point for report generation. It takes
        analysis data, creates appropriate visualizations using viz
        modules, and outputs a formatted report.

        Args:
            data: Analysis data from core modules
            output_path: Path for output file
            config: Report configuration

        Returns:
            Path: Path to generated report

        Example:
            >>> generator = ReportGenerator(config)
            >>> report_path = generator.generate(
            ...     analysis_data,
            ...     Path("report.html"),
            ...     ReportConfig(include_charts=True)
            ... )
        """
        if config is None:
            config = ReportConfig()

        self.logger.info(f"Generating {config.format} report: {output_path}")

        # Clear previous sections
        self.sections = []

        # Build metadata
        self.metadata = self._build_metadata(data, config)

        # Create report sections using viz modules
        if config.include_summary:
            self.sections.append(self._create_summary_section(data))

        # Add analysis sections based on available data
        if "complexity" in data:
            self.sections.append(self._create_complexity_section(data["complexity"], config))

        if "contributors" in data:
            self.sections.append(self._create_contributors_section(data["contributors"], config))

        if "hotspots" in data:
            self.sections.append(self._create_hotspots_section(data["hotspots"], config))

        if "dependencies" in data:
            self.sections.append(self._create_dependencies_section(data["dependencies"], config))

        if "coupling" in data:
            self.sections.append(self._create_coupling_section(data["coupling"], config))

        if "momentum" in data:
            self.sections.append(self._create_momentum_section(data["momentum"], config))

        if config.include_recommendations:
            self.sections.append(self._create_recommendations_section(data))

        # Generate output based on format
        if config.format == "html":
            from .html_reporter import HTMLReporter

            reporter = HTMLReporter(self.config)
            return reporter.generate(self.sections, self.metadata, output_path, config)
        elif config.format == "markdown":
            from .markdown_reporter import MarkdownReporter

            reporter = MarkdownReporter(self.config)
            return reporter.generate(self.sections, self.metadata, output_path, config)
        elif config.format == "json":
            return self._generate_json_report(output_path)
        else:
            raise ValueError(f"Unsupported report format: {config.format}")

    def _build_metadata(self, data: Dict[str, Any], config: ReportConfig) -> Dict[str, Any]:
        """Build report metadata.

        Args:
            data: Analysis data
            config: Report configuration

        Returns:
            Dict[str, Any]: Report metadata
        """
        metadata = {
            "title": config.title,
            "generated_at": datetime.now().isoformat(),
            "generator_version": "1.0.0",
            "format": config.format,
            "analysis_summary": self._extract_summary_metrics(data),
        }

        # Add data source information
        if "source" in data:
            metadata["source"] = data["source"]

        return metadata

    def _extract_summary_metrics(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract summary metrics from analysis data.

        Args:
            data: Analysis data

        Returns:
            Dict[str, Any]: Summary metrics
        """
        summary = {
            "total_files": data.get("total_files", 0),
            "total_lines": data.get("total_lines", 0),
            "languages": data.get("languages", []),
            "health_score": data.get("health_score", 0),
            "critical_issues": 0,
            "total_issues": 0,
        }

        # Count issues from various sources
        if "complexity" in data:
            summary["critical_issues"] += data["complexity"].get("critical_count", 0)
            summary["total_issues"] += data["complexity"].get("complex_functions", 0)

        if "hotspots" in data:
            summary["critical_issues"] += data["hotspots"].get("critical_count", 0)
            summary["total_issues"] += data["hotspots"].get("total_hotspots", 0)

        if "dependencies" in data:
            summary["total_issues"] += data["dependencies"].get("circular_count", 0)

        return summary

    def _create_summary_section(self, data: Dict[str, Any]) -> ReportSection:
        """Create executive summary section.

        Args:
            data: Analysis data

        Returns:
            ReportSection: Summary section
        """
        section = ReportSection(
            id="summary", title="Executive Summary", level=1, order=1, icon="📊"
        )

        summary = self.metadata.get("analysis_summary", {})

        # Build summary content
        health_score = summary.get("health_score", 0)
        if health_score >= 80:
            health_status = "excellent"
            health_icon = "✅"
        elif health_score >= 60:
            health_status = "good"
            health_icon = "✔️"
        elif health_score >= 40:
            health_status = "fair"
            health_icon = "⚠️"
        else:
            health_status = "needs improvement"
            health_icon = "❌"

        content = [
            f"The codebase is in **{health_status}** condition {health_icon} with a health score of **{health_score:.1f}/100**.",
            "",
            "### Key Findings",
            "",
        ]

        if summary.get("critical_issues", 0) > 0:
            content.append(
                f"- 🚨 **{summary['critical_issues']} critical issues** require immediate attention"
            )

        if summary.get("total_issues", 0) > 0:
            content.append(
                f"- ⚠️ Total of **{summary['total_issues']} issues** identified across all categories"
            )

        content.append(
            f"- 📊 Analyzed **{summary.get('total_files', 0)} files** with **{summary.get('total_lines', 0):,} lines** of code"
        )

        section.content = content

        # Add summary metrics
        section.metrics = {
            "Health Score": f"{health_score:.1f}/100",
            "Files Analyzed": summary.get("total_files", 0),
            "Total Lines": f"{summary.get('total_lines', 0):,}",
            "Critical Issues": summary.get("critical_issues", 0),
        }

        return section

    def _create_complexity_section(
        self, complexity_data: Dict[str, Any], config: ReportConfig
    ) -> ReportSection:
        """Create complexity analysis section using viz modules.

        Args:
            complexity_data: Complexity analysis data
            config: Report configuration

        Returns:
            ReportSection: Complexity section
        """
        section = ReportSection(
            id="complexity", title="Complexity Analysis", level=1, order=2, icon="🔍"
        )

        # Use ComplexityVisualizer for charts
        viz = ComplexityVisualizer(chart_config=config.chart_config)

        # Add metrics
        section.metrics = {
            "Average Complexity": f"{complexity_data.get('avg_complexity', 0):.2f}",
            "Maximum Complexity": complexity_data.get("max_complexity", 0),
            "Complex Functions": complexity_data.get("complex_functions", 0),
            "Total Functions": complexity_data.get("total_functions", 0),
        }

        # Add distribution chart if requested
        if config.include_charts:
            chart = viz.create_distribution_chart(complexity_data)
            section.add_chart(chart)

            # Add top complex functions chart
            if "complex_items" in complexity_data:
                chart = viz.create_top_complex_chart(
                    complexity_data["complex_items"], limit=config.max_items
                )
                section.add_chart(chart)

            # Add trend chart if available
            if "trend_data" in complexity_data:
                chart = viz.create_trend_chart(complexity_data["trend_data"])
                section.add_chart(chart)

        # Add complex functions table
        if "complex_items" in complexity_data:
            table_data = self._create_complex_functions_table(
                complexity_data["complex_items"][: config.max_items]
            )
            section.add_table(table_data)

        # Add code snippets if requested
        if config.include_code_snippets and "complex_items" in complexity_data:
            for item in complexity_data["complex_items"][:3]:
                if "code" in item:
                    section.code_snippets.append(
                        {
                            "filename": item.get("file", ""),
                            "language": item.get("language", "python"),
                            "code": item["code"],
                            "highlight_lines": item.get("highlight_lines", []),
                        }
                    )

        return section

    def _create_contributors_section(
        self, contributor_data: Dict[str, Any], config: ReportConfig
    ) -> ReportSection:
        """Create contributors analysis section using viz modules.

        Args:
            contributor_data: Contributor analysis data
            config: Report configuration

        Returns:
            ReportSection: Contributors section
        """
        section = ReportSection(
            id="contributors", title="Contributor Analysis", level=1, order=3, icon="👥"
        )

        # Use ContributorVisualizer for charts
        viz = ContributorVisualizer(chart_config=config.chart_config)

        # Add metrics
        section.metrics = {
            "Total Contributors": contributor_data.get("total_contributors", 0),
            "Active Contributors": contributor_data.get("active_contributors", 0),
            "Bus Factor": contributor_data.get("bus_factor", 0),
            "Avg Commits/Contributor": f"{contributor_data.get('avg_commits_per_contributor', 0):.1f}",
        }

        # Add visualizations
        if config.include_charts:
            # Contribution chart
            if "contributors" in contributor_data:
                chart = viz.create_contribution_chart(
                    contributor_data["contributors"], metric="commits", limit=config.max_items
                )
                section.add_chart(chart)

                # Distribution pie chart
                chart = viz.create_distribution_pie(
                    contributor_data["contributors"], metric="commits", top_n=5
                )
                section.add_chart(chart)

            # Activity timeline
            if "activity_data" in contributor_data:
                chart = viz.create_activity_timeline(contributor_data["activity_data"])
                section.add_chart(chart)

            # Bus factor gauge
            chart = viz.create_bus_factor_gauge(
                contributor_data.get("bus_factor", 0), contributor_data.get("total_contributors", 1)
            )
            section.add_chart(chart)

        # Add contributors table
        if "contributors" in contributor_data:
            table_data = self._create_contributors_table(
                contributor_data["contributors"][: config.max_items]
            )
            section.add_table(table_data)

        return section

    def _create_hotspots_section(
        self, hotspot_data: Dict[str, Any], config: ReportConfig
    ) -> ReportSection:
        """Create hotspots analysis section using viz modules.

        Args:
            hotspot_data: Hotspot analysis data
            config: Report configuration

        Returns:
            ReportSection: Hotspots section
        """
        section = ReportSection(id="hotspots", title="Code Hotspots", level=1, order=4, icon="🔥")

        # Use HotspotVisualizer for charts
        viz = HotspotVisualizer(chart_config=config.chart_config)

        # Add metrics
        section.metrics = {
            "Total Hotspots": hotspot_data.get("total_hotspots", 0),
            "Critical": hotspot_data.get("critical_count", 0),
            "High Risk": hotspot_data.get("high_count", 0),
            "Files Analyzed": hotspot_data.get("files_analyzed", 0),
        }

        # Add visualizations
        if config.include_charts:
            # Hotspot bubble chart
            if "hotspots" in hotspot_data:
                chart = viz.create_hotspot_bubble(hotspot_data["hotspots"], limit=50)
                section.add_chart(chart)

                # Risk matrix
                chart = viz.create_risk_matrix(hotspot_data["hotspots"])
                section.add_chart(chart)

            # Hotspot heatmap
            if "hotspots" in hotspot_data:
                chart = viz.create_hotspot_heatmap(
                    hotspot_data["hotspots"], metric_x="change_frequency", metric_y="complexity"
                )
                section.add_chart(chart)

        # Add hotspots table
        if "hotspots" in hotspot_data:
            table_data = self._create_hotspots_table(hotspot_data["hotspots"][: config.max_items])
            section.add_table(table_data)

        return section

    def _create_dependencies_section(
        self, dependency_data: Dict[str, Any], config: ReportConfig
    ) -> ReportSection:
        """Create dependencies analysis section using viz modules.

        Args:
            dependency_data: Dependency analysis data
            config: Report configuration

        Returns:
            ReportSection: Dependencies section
        """
        section = ReportSection(
            id="dependencies", title="Dependency Analysis", level=1, order=5, icon="🔗"
        )

        # Use DependencyVisualizer for charts
        viz = DependencyVisualizer(chart_config=config.chart_config)

        # Add metrics
        section.metrics = {
            "Total Modules": dependency_data.get("total_modules", 0),
            "Total Dependencies": dependency_data.get("total_dependencies", 0),
            "External Dependencies": dependency_data.get("external_dependencies", 0),
            "Circular Dependencies": dependency_data.get("circular_count", 0),
        }

        # Add visualizations
        if config.include_charts:
            # Dependency graph
            if "dependencies" in dependency_data:
                chart = viz.create_dependency_graph(
                    dependency_data["dependencies"], highlight_circular=True
                )
                section.add_chart(chart)

            # Circular dependencies
            if dependency_data.get("circular_count", 0) > 0:
                if "circular_chains" in dependency_data:
                    chart = viz.create_circular_dependencies_chart(
                        dependency_data["circular_chains"]
                    )
                    section.add_chart(chart)

        # Add tables
        if "most_dependent" in dependency_data:
            table_data = self._create_dependency_table(
                dependency_data["most_dependent"][: config.max_items]
            )
            section.add_table(table_data)

        return section

    def _create_coupling_section(
        self, coupling_data: Dict[str, Any], config: ReportConfig
    ) -> ReportSection:
        """Create coupling analysis section using viz modules.

        Args:
            coupling_data: Coupling analysis data
            config: Report configuration

        Returns:
            ReportSection: Coupling section
        """
        section = ReportSection(
            id="coupling", title="Coupling Analysis", level=1, order=6, icon="🔄"
        )

        # Use CouplingVisualizer for charts
        viz = CouplingVisualizer(chart_config=config.chart_config)

        # Add metrics
        section.metrics = {
            "Average Coupling": f"{coupling_data.get('avg_coupling', 0):.2f}",
            "Max Coupling": coupling_data.get("max_coupling", 0),
            "Highly Coupled": coupling_data.get("highly_coupled_count", 0),
            "Total Modules": coupling_data.get("total_modules", 0),
        }

        # Add visualizations
        if config.include_charts:
            # Coupling network
            if "coupling_data" in coupling_data:
                chart = viz.create_coupling_network(coupling_data["coupling_data"], min_coupling=2)
                section.add_chart(chart)

            # Instability chart
            if "instability_data" in coupling_data:
                chart = viz.create_instability_chart(coupling_data["instability_data"])
                section.add_chart(chart)

        return section

    def _create_momentum_section(
        self, momentum_data: Dict[str, Any], config: ReportConfig
    ) -> ReportSection:
        """Create momentum analysis section using viz modules.

        Args:
            momentum_data: Momentum analysis data
            config: Report configuration

        Returns:
            ReportSection: Momentum section
        """
        section = ReportSection(
            id="momentum", title="Development Momentum", level=1, order=7, icon="📈"
        )

        # Use MomentumVisualizer for charts
        viz = MomentumVisualizer(chart_config=config.chart_config)

        # Add current sprint metrics
        if "current_sprint" in momentum_data:
            sprint = momentum_data["current_sprint"]
            section.metrics = {
                "Current Velocity": sprint.get("velocity", 0),
                "Sprint Progress": f"{sprint.get('completed', 0)}/{sprint.get('planned', 0)}",
                "Days Remaining": sprint.get("days_remaining", 0),
                "On Track": "✅" if sprint.get("on_track", False) else "❌",
            }

        # Add visualizations
        if config.include_charts:
            # Velocity chart
            if "velocity_data" in momentum_data:
                chart = viz.create_velocity_chart(momentum_data["velocity_data"], show_trend=True)
                section.add_chart(chart)

            # Burndown chart
            if "burndown" in momentum_data:
                chart = viz.create_burndown_chart(momentum_data["burndown"])
                section.add_chart(chart)

            # Team metrics radar
            if "team_metrics" in momentum_data:
                chart = viz.create_team_velocity_radar(momentum_data["team_metrics"])
                section.add_chart(chart)

        return section

    def _create_recommendations_section(self, data: Dict[str, Any]) -> ReportSection:
        """Create recommendations section.

        Args:
            data: Complete analysis data

        Returns:
            ReportSection: Recommendations section
        """
        section = ReportSection(
            id="recommendations", title="Recommendations", level=1, order=99, icon="💡"
        )

        recommendations = []

        # Collect recommendations from various sources
        if "complexity" in data:
            if data["complexity"].get("avg_complexity", 0) > 15:
                recommendations.append(
                    {
                        "priority": "high",
                        "category": "complexity",
                        "action": "Refactor complex functions to reduce cognitive load",
                        "impact": "Improved maintainability and reduced bug risk",
                    }
                )

        if "hotspots" in data:
            if data["hotspots"].get("critical_count", 0) > 0:
                recommendations.append(
                    {
                        "priority": "critical",
                        "category": "hotspots",
                        "action": "Address critical hotspots with high change frequency and complexity",
                        "impact": "Reduced technical debt and improved stability",
                    }
                )

        if "dependencies" in data:
            if data["dependencies"].get("circular_count", 0) > 0:
                recommendations.append(
                    {
                        "priority": "high",
                        "category": "architecture",
                        "action": "Resolve circular dependencies to improve architecture",
                        "impact": "Better modularity and easier testing",
                    }
                )

        if "contributors" in data:
            if data["contributors"].get("bus_factor", 0) <= 2:
                recommendations.append(
                    {
                        "priority": "medium",
                        "category": "team",
                        "action": "Improve knowledge sharing to increase bus factor",
                        "impact": "Reduced key person risk",
                    }
                )

        # Sort by priority
        priority_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        recommendations.sort(key=lambda x: priority_order.get(x["priority"], 99))

        # Format as content
        content = []
        for rec in recommendations:
            icon = (
                "🚨"
                if rec["priority"] == "critical"
                else "⚠️"
                if rec["priority"] == "high"
                else "💡"
            )
            content.append(f"{icon} **{rec['action']}**")
            content.append(f"   Impact: {rec['impact']}")
            content.append("")

        section.content = content

        return section

    def _create_complex_functions_table(
        self, complex_items: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Create table data for complex functions.

        Args:
            complex_items: List of complex function data

        Returns:
            Dict[str, Any]: Table configuration
        """
        return {
            "headers": ["Function", "File", "Complexity", "Lines", "Risk"],
            "rows": [
                [
                    item.get("name", "Unknown"),
                    item.get("file", "Unknown"),
                    item.get("complexity", 0),
                    item.get("lines", 0),
                    self._get_risk_level(item.get("complexity", 0)),
                ]
                for item in complex_items
            ],
        }

    def _create_contributors_table(self, contributors: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create table data for contributors.

        Args:
            contributors: List of contributor data

        Returns:
            Dict[str, Any]: Table configuration
        """
        return {
            "headers": ["Contributor", "Commits", "Lines Changed", "Files", "Last Active"],
            "rows": [
                [
                    contributor.get("name", "Unknown"),
                    contributor.get("commits", 0),
                    contributor.get("lines", 0),
                    contributor.get("files", 0),
                    self._format_days_ago(contributor.get("last_commit_days_ago", 999)),
                ]
                for contributor in contributors
            ],
        }

    def _create_hotspots_table(self, hotspots: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create table data for hotspots.

        Args:
            hotspots: List of hotspot data

        Returns:
            Dict[str, Any]: Table configuration
        """
        return {
            "headers": ["File", "Risk Level", "Changes", "Complexity", "Score"],
            "rows": [
                [
                    hotspot.get("file", "Unknown"),
                    hotspot.get("risk_level", "low").upper(),
                    hotspot.get("change_frequency", 0),
                    hotspot.get("complexity", 0),
                    f"{hotspot.get('risk_score', 0):.1f}",
                ]
                for hotspot in hotspots
            ],
        }

    def _create_dependency_table(self, modules: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create table data for dependencies.

        Args:
            modules: List of module dependency data

        Returns:
            Dict[str, Any]: Table configuration
        """
        return {
            "headers": ["Module", "Dependencies", "Dependents", "Total Coupling"],
            "rows": [
                [
                    module.get("name", "Unknown"),
                    module.get("dependencies", 0),
                    module.get("dependents", 0),
                    module.get("dependencies", 0) + module.get("dependents", 0),
                ]
                for module in modules
            ],
        }

    def _get_risk_level(self, complexity: int) -> str:
        """Get risk level for complexity value.

        Args:
            complexity: Complexity value

        Returns:
            str: Risk level
        """
        if complexity > 20:
            return "Critical"
        elif complexity > 10:
            return "High"
        elif complexity > 5:
            return "Medium"
        else:
            return "Low"

    def _format_days_ago(self, days: int) -> str:
        """Format days ago as human-readable string.

        Args:
            days: Number of days

        Returns:
            str: Formatted string
        """
        if days == 0:
            return "Today"
        elif days == 1:
            return "Yesterday"
        elif days <= 7:
            return f"{days} days ago"
        elif days <= 30:
            weeks = days // 7
            return f"{weeks} week{'s' if weeks > 1 else ''} ago"
        elif days <= 365:
            months = days // 30
            return f"{months} month{'s' if months > 1 else ''} ago"
        else:
            years = days // 365
            return f"{years} year{'s' if years > 1 else ''} ago"

    def _generate_json_report(self, output_path: Path) -> Path:
        """Generate JSON format report.

        Args:
            output_path: Output file path

        Returns:
            Path: Path to generated report
        """
        report_data = {"metadata": self.metadata, "sections": self._sections_to_dict(self.sections)}

        with open(output_path, "w") as f:
            json.dump(report_data, f, indent=2, default=str)

        self.logger.info(f"JSON report generated: {output_path}")
        return output_path

    def _sections_to_dict(self, sections: List[ReportSection]) -> List[Dict[str, Any]]:
        """Convert sections to dictionary format.

        Args:
            sections: List of report sections

        Returns:
            List[Dict[str, Any]]: Sections as dictionaries
        """
        result = []
        for section in sections:
            section_dict = {
                "id": section.id,
                "title": section.title,
                "level": section.level,
                "order": section.order,
                "icon": section.icon,
                "content": section.content,
                "metrics": section.metrics,
                "tables": section.tables,
                "charts": section.charts,
                "code_snippets": section.code_snippets,
                "visible": section.visible,
                "collapsed": section.collapsed,
            }

            if section.subsections:
                section_dict["subsections"] = self._sections_to_dict(section.subsections)

            result.append(section_dict)

        return result
